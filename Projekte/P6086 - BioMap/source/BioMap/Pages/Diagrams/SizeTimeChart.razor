@page "/lists/size_time_chart"
@inject Microsoft.Extensions.Localization.IStringLocalizer<App> Localize
@inject DataService DS
@inject IJSRuntime JSRuntime
@using BioMap
@using ChartJs.Blazor.Charts
@using ChartJs.Blazor.ChartJS.Common.Properties
@using ChartJs.Blazor.ChartJS.Common.Enums
@using ChartJs.Blazor.ChartJS.Common.Axes
@using ChartJs.Blazor.ChartJS.Common.Axes.Ticks
@using ChartJs.Blazor.ChartJS.Common
@using ChartJs.Blazor.ChartJS.Common.Handlers
@using ChartJs.Blazor.ChartJS.Common.Time
@using ChartJs.Blazor.ChartJS.LineChart
@using ChartJs.Blazor.Util

<h1>@Localize["Length / Time Chart"]</h1>

<CheckBox @ref="CheckBoxFit" LabelText=@Localize["Fit growing curves"] OnAnyChangedCallback="@CheckBoxFit_CheckedChanged" />

<ChartJsLineChart @ref="_chartJs" Config="@_config" Width="600" Height="300" />

@code {
  private LineConfig _config;
  private ChartJsLineChart _chartJs;
  private CheckBox CheckBoxFit;

  protected override void OnInitialized() {
    base.OnInitialized();
    _config = new LineConfig
    {
      Options = new LineOptions
      {
        Animation=new Animation
        {
          Duration=0,
        },
        Title = new OptionsTitle
        {
          Text="XXX",
          Display = false,
        },
        Legend = new Legend
        {
          Display = false,
        },
        Scales = new Scales
        {
          xAxes = new List<CartesianAxis>
        {
            new TimeAxis
            {
              Distribution = TimeDistribution.Linear,
              Time = new TimeOptions
              {
                Unit = TimeMeasurement.Month,
                Round = TimeMeasurement.Day,
                TooltipFormat = "DD.MM.YYYY HH:mm:ss",
              },
              ScaleLabel = new ScaleLabel
              {
                LabelString = "Time"
              }
            }
          }
        },
      },
    };
    DS.Filter.FilterChanged+=(sender,ev) =>
    {
      RefreshData();
      base.InvokeAsync(StateHasChanged);
    };
    RefreshData();
  }
  private void CheckBoxFit_CheckedChanged(EventArgs e) {
    RefreshData();
    base.InvokeAsync(StateHasChanged);
  }
  private void RefreshData() {
    var aaIndisByIId = DS.GetIndividuals();
    _config.Options.Legend.Display=false;
    _config.Data.Datasets.Clear();
    // Ideale Wachstumskurven hinzufügen.
    for (int nYoB = 2012;nYoB<2021;nYoB++) {
      string sYobColor = Element.GetColorForYearOfBirth(nYoB);
      var lineSet = new LineDataset<TimeTuple<double>>
      {
        BackgroundColor = sYobColor,
        BorderWidth = 4,
        BorderDash= new[] { 10,5 },
        PointHoverBorderWidth = 4,
        BorderColor = sYobColor,
        PointRadius = 0,
        //ShowLine = true,
      };
      var fg = new GrowthFunc()
      {
        DateOfBirth=new DateTime(nYoB,1,1),
      };
      for (var dt = new DateTime(2019,4,1);dt<new DateTime(2020,11,1);dt+=TimeSpan.FromDays(7)) {
        try {
          var l = fg.GetSize(dt);
          var t = new Moment(dt);
          if (l > 10) {
            lineSet.Add(new TimeTuple<double>(t,l));
          }
        } catch { }
      }
      if (lineSet.Data.Count>=2) {
        _config.Data.Datasets.Add(lineSet);
      }
    }
    // Wachstumskurven der Individuen hinzufügen.
    foreach (var idx in aaIndisByIId.Keys) {
      try {
        if (this.CheckBoxFit!=null && this.CheckBoxFit.Checked) {
          // Gefittete Wachstumskurve.
          DateTime? dtFittedYearOfBirth = null;
          var lsf = new LeastSquareFit();
          if (aaIndisByIId[idx].Count>=2) {
            var ldaPoints = new List<double[]>();
            foreach (var el in aaIndisByIId[idx]) {
              try {
                var l = el.ElementProp.IndivData.MeasuredData.HeadBodyLength;
                if (l!=0) {
                  double t = Utilities.Years_from_DateTime(el.ElementProp.CreationTime);
                  ldaPoints.Add(new double[] { t,l });
                }
              } catch { }
            }
            lsf.Optimize(
              new double[][] { new double[] { 2010,2025 } },
              ldaPoints.ToArray(),
              (daParams,daaPoints) =>
              {
                double yearsBirth = daParams[0];
                var fg = new GrowthFunc()
                {
                  DateOfBirth=Utilities.DateTime_from_Years(yearsBirth),
                };
                double dDevSum = 0;
                for (int i = 0;i<daaPoints.Length;i++) {
                  double years = daaPoints[i][0];
                  double lCalc = fg.GetSize(years);
                  double lReal = daaPoints[i][1];
                  double dDev = lReal-lCalc;
                  // Daten aus der Jugend werden stärker gewichtet.
                  //dDevSum+=(dDev*dDev)/Math.Max(0.5,years-yearsBirth);
                  dDevSum+=(dDev*dDev);
                }
                return dDevSum;
              },
              0.5,
              0.001,
              out double[] daBestParams,
              LeastSquareFit.Method.RandomThenMonotone);
            dtFittedYearOfBirth = Utilities.DateTime_from_Years(daBestParams[0]);
            var growthFunc = new GrowthFunc()
            {
              DateOfBirth=dtFittedYearOfBirth.Value,
            };
            string sYobColor = Element.GetColorForYearOfBirth(dtFittedYearOfBirth.Value.Year);
            var lineSetCurve = new LineDataset<TimeTuple<double>>
            {
              BackgroundColor = sYobColor,
              BorderWidth = 2,
              PointHoverBorderWidth = 0,
              BorderColor = sYobColor,
              PointRadius = 0,
              Label="YoB: "+dtFittedYearOfBirth?.ToString("yyyy-MM-dd"),
            };
            {
              var dtB = aaIndisByIId[idx][0].ElementProp.CreationTime;
              var dtE = aaIndisByIId[idx][aaIndisByIId[idx].Count-1].ElementProp.CreationTime;
              var tsT = (dtE-TimeSpan.FromSeconds(30))-dtB;
              int nSteps = (int)Math.Ceiling(tsT/TimeSpan.FromDays(7));
              var tsDelta = new TimeSpan(tsT.Ticks/nSteps);
              for (var dt = dtB;dt<=dtE;dt+=tsDelta) {
                try {
                  var l = growthFunc.GetSize(dt);
                  var t = new Moment(dt);
                  if (l > 10) {
                    lineSetCurve.Add(new TimeTuple<double>(t,l));
                  }
                } catch { }
              }
            }
            if (lineSetCurve.Data.Count>=2) {
              _config.Data.Datasets.Add(lineSetCurve);
              //_config.Options.Legend.Display=true;
            }
          }
          // Datenpunkte.
          {
            string sYobColor = Element.GetColorForYearOfBirth(dtFittedYearOfBirth.HasValue ? dtFittedYearOfBirth.Value.Year : aaIndisByIId[idx][0].ElementProp.IndivData?.YearOfBirth);
            var lineSetPoints = new LineDataset<TimeTuple<double>>
            {
              BackgroundColor = sYobColor,
              BorderWidth = 0,
              PointHoverBorderWidth = 4,
              BorderColor = sYobColor,
              PointRadius = 3,
              ShowLine = false,
            };
            foreach (var el in aaIndisByIId[idx]) {
              try {
                var l = el.ElementProp.IndivData.MeasuredData.HeadBodyLength;
                if (l>0) {
                  var t = new Moment(el.ElementProp.CreationTime);
                  lineSetPoints.Add(new TimeTuple<double>(t,l));
                }
              } catch { }
            }
            if (lineSetPoints.Data.Count>=1) {
              _config.Data.Datasets.Add(lineSetPoints);
            }
          }
        } else {
          // Interpolation durch Datenpunkte.
          string sYobColor = aaIndisByIId[idx][0].GetColorForYearOfBirth();
          var lineSet = new LineDataset<TimeTuple<double>>
          {
            BackgroundColor = sYobColor,
            BorderWidth = 2,
            PointHoverBorderWidth = 4,
            BorderColor = sYobColor,
            PointRadius = 3,
            //ShowLine = true,
          };
          foreach (var el in aaIndisByIId[idx]) {
            try {
              var l = el.ElementProp.IndivData.MeasuredData.HeadBodyLength;
              if (l!=0) {
                var t = new Moment(el.ElementProp.CreationTime);
                lineSet.Add(new TimeTuple<double>(t,l));
              }
            } catch { }
          }
          if (lineSet.Data.Count>=1) {
            _config.Data.Datasets.Add(lineSet);
          }
        }
      } catch {
      }
    }
  }
}
